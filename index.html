<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimisateur de Murs R√©fractaires - Jointures D√©cal√©es</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
            min-height: 100vh; 
            padding: 20px; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 15px; 
            box-shadow: 0 15px 50px rgba(0,0,0,0.2); 
            overflow: hidden; 
        }
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 25px; 
            text-align: center; 
        }
        .main-content { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 25px; 
            padding: 25px; 
        }
        .section { 
            background: #f8f9fa; 
            border-radius: 10px; 
            padding: 20px; 
            border: 2px solid #e9ecef; 
        }
        .section h2 { 
            color: #2c3e50; 
            margin-bottom: 15px; 
            font-size: 1.4rem; 
            border-bottom: 2px solid #3498db; 
            padding-bottom: 8px; 
        }
        .input-group { margin-bottom: 15px; }
        .input-group label { 
            display: block; 
            margin-bottom: 5px; 
            font-weight: 600; 
            color: #34495e; 
        }
        .input-group input, .input-group select { 
            width: 100%; 
            padding: 10px; 
            border: 2px solid #ddd; 
            border-radius: 6px; 
            font-size: 14px; 
            transition: border-color 0.3s;
        }
        .input-group input:focus, .input-group select:focus {
            border-color: #3498db;
            outline: none;
        }
        .dimensions-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 10px; 
        }
        .btn { 
            background: #27ae60; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 6px; 
            font-weight: 600; 
            cursor: pointer; 
            width: 100%; 
            margin-top: 10px; 
            transition: all 0.3s; 
            font-size: 14px;
        }
        .btn:hover { 
            background: #229954; 
            transform: translateY(-1px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-secondary { background: #3498db; }
        .btn-secondary:hover { background: #2980b9; }
        .btn-danger { background: #e74c3c; }
        .btn-danger:hover { background: #c0392b; }
        .btn-warning { background: #f39c12; }
        .btn-warning:hover { background: #e67e22; }
        .btn-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 10px; 
        }
        .stock-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px; 
            background: white; 
            border-radius: 6px; 
            overflow: hidden; 
            font-size: 0.9rem; 
        }
        .stock-table th, .stock-table td { 
            padding: 8px; 
            text-align: left; 
            border-bottom: 1px solid #ddd; 
        }
        .stock-table th { 
            background: #34495e; 
            color: white; 
            font-weight: 600; 
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .stock-table tr:hover { 
            background: #f1f2f6; 
        }
        .stock-container { 
            max-height: 250px; 
            overflow-y: auto; 
            border: 1px solid #ddd; 
            border-radius: 6px; 
        }
        .result-section { 
            grid-column: 1 / -1; 
            margin-top: 20px; 
        }
        .result-grid { 
            display: grid; 
            grid-template-columns: 2fr 1fr 1fr; 
            gap: 20px; 
            margin-top: 15px; 
        }
        .wall-visualization { 
            background: white; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            padding: 15px; 
            min-height: 300px; 
            position: relative; 
        }
        .block { 
            position: absolute; 
            border: 1px solid #333; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 9px; 
            font-weight: 600; 
            color: white; 
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5); 
            cursor: pointer; 
            transition: all 0.2s;
        }
        .block:hover {
            transform: scale(1.05);
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .stats { 
            background: #e8f5e8; 
            border: 2px solid #27ae60; 
            border-radius: 8px; 
            padding: 15px; 
        }
        .stat-item { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 8px; 
            padding: 5px 0; 
            border-bottom: 1px solid #ccc; 
        }
        .alert { 
            padding: 12px; 
            border-radius: 6px; 
            margin: 10px 0; 
        }
        .alert-success { 
            background: #d4edda; 
            border: 1px solid #c3e6cb; 
            color: #155724; 
        }
        .alert-warning { 
            background: #fff3cd; 
            border: 1px solid #ffeaa7; 
            color: #856404; 
        }
        .alert-danger { 
            background: #f8d7da; 
            border: 1px solid #f5c6cb; 
            color: #721c24; 
        }
        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .cursor {
            position: absolute;
            width: 2px;
            height: 2px;
            background: red;
            display: none;
            z-index: 10;
            pointer-events: none;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.3s ease;
        }
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1001;
            pointer-events: none;
            white-space: nowrap;
        }
        @media (max-width: 1000px) {
            .main-content, .result-grid { grid-template-columns: 1fr; }
            .btn-grid { grid-template-columns: 1fr; }
            .dimensions-grid { grid-template-columns: 1fr 1fr; }
        }
        @media (max-width: 600px) {
            .dimensions-grid { grid-template-columns: 1fr; }
            .container { margin: 10px; }
            .main-content { padding: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß± Optimisateur de Murs R√©fractaires</h1>
            <p>Version avec Jointures D√©cal√©es (50mm minimum) + Tri par Famille/Qualit√©</p>
        </div>
        <div class="main-content">
            <div class="section">
                <h2>üìê Configuration</h2>
                <div class="input-group">
                    <label>Dimensions du Mur (mm)</label>
                    <div class="dimensions-grid">
                        <div><label>Longueur</label><input type="number" id="targetLength" value="3000" min="100"></div>
                        <div><label>Largeur</label><input type="number" id="targetWidth" value="2000" min="100"></div>
                        <div><label>√âpaisseur</label><input type="number" id="targetThickness" value="250" min="50"></div>
                    </div>
                </div>
                <div class="input-group">
                    <label>Nombre de Rang√©es Horizontales</label>
                    <input type="number" id="numRows" value="3" min="1" max="10" step="1">
                    <small style="color: #666; font-size: 0.8rem;">Guide pour diviser le mur (hauteurs adaptatives)</small>
                </div>
                <div class="input-group">
                    <label>D√©calage minimum des jointures (mm)</label>
                    <input type="number" id="jointOffset" value="50" min="10" max="200" step="10">
                    <small style="color: #666; font-size: 0.8rem;">Distance minimale entre jointures de rang√©es adjacentes</small>
                </div>
                <button class="btn" onclick="optimizeWall()">üöÄ Optimiser avec Jointures D√©cal√©es</button>
            </div>
            <div class="section">
                <h2>üì¶ Stock</h2>
                <div class="input-group">
                    <label>üìÅ Import Excel</label>
                    <input type="file" id="excelFile" accept=".xlsx,.xls" style="border: 2px dashed #3498db; background: #f8f9fa;">
                </div>
                <div class="btn-grid">
                    <button class="btn btn-secondary" onclick="loadExample()">üìù Charger Exemple</button>
                    <button class="btn btn-danger" onclick="clearStock()">üóëÔ∏è Vider Stock</button>
                </div>
                <div class="input-group">
                    <label>üîç Filtres</label>
                    <div class="dimensions-grid">
                        <div><label>Famille</label><select id="familyFilter"><option value="">Toutes les familles</option></select></div>
                        <div><label>Qualit√©</label><select id="qualityFilter"><option value="">Toutes les qualit√©s</option></select></div>
                        <div></div>
                    </div>
                </div>
                <div id="importStatus" style="margin-top: 10px; display: none;"></div>
                <div class="input-group">
                    <label>Stock Charg√© (<span id="stockCount">0</span> casiers - <span id="filteredCount">0</span> filtr√©s)</label>
                    <div class="stock-container">
                        <table class="stock-table">
                            <thead><tr><th>Casier</th><th>Famille</th><th>Qualit√©</th><th>Longueur</th><th>Largeur</th><th>√âpaisseur</th><th>Compatible</th><th>Score</th></tr></thead>
                            <tbody id="stockTableBody"><tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">Chargez un stock pour commencer</td></tr></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div class="section result-section" id="resultsSection" style="display: none;">
            <h2>üéØ R√©sultats avec Jointures D√©cal√©es</h2>
            <div id="status" class="alert alert-success">Optimisation en cours...</div>
            <div class="progress-bar" id="progressBarContainer" style="display: none;">
                <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
            </div>
            <div class="result-grid">
                <div class="wall-visualization">
                    <h3 style="text-align: center; margin-bottom: 10px;"></h3>
                    <div id="wallBlocks"></div>
                    <div id="cursor" class="cursor"></div>
                    <div id="coordinates" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0, 0, 0, 0.5); color: white; padding: 5px; border-radius: 3px; font-size: 12px; z-index: 10;">X: 0, Y: 0</div>
                    <div style="position: absolute; top: 10px; right: 10px; background: #27ae60; color: white; padding: 3px 8px; border-radius: 10px; font-size: 11px; font-weight: bold;" id="coverageDisplay">100%</div>
                </div>
                <div class="stats">
                    <h3>üìä Statistiques</h3>
                    <div class="stat-item"><span>Casiers utilis√©s :</span><strong id="blocksUsed">0</strong></div>
                    <div class="stat-item"><span>Rang√©es cr√©√©es :</span><strong id="rowsCreated">0</strong></div>
                    <div class="stat-item"><span>D√©coupes totales :</span><strong id="cutsNeeded">0</strong></div>
                    <div class="stat-item"><span>Violations jointures :</span><strong id="jointViolations">0</strong></div>
                    <div class="stat-item"><span>Couverture :</span><strong id="coverage">100%</strong></div>
                    <div class="stat-item"><span>Volume chutes :</span><strong id="wasteVolume">0 mm¬≥</strong></div>
                    <div class="stat-item"><span>Volume mur :</span><strong id="wallVolume">0 mm¬≥</strong></div>
                    <div class="stat-item"><span>Efficacit√© :</span><strong id="efficiency">0%</strong></div>
                </div>
                <div class="stats">
                    <h3>üìã Casiers Utilis√©s</h3>
                    <div id="blocksList" style="max-height: 250px; overflow-y: auto; font-size: 0.85rem;"></div>
                </div>
            </div>
            <div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid #ddd;">
                <h3 style="color: #2c3e50; margin-bottom: 10px;">üìÑ Export des R√©sultats</h3>
                <button class="btn btn-warning" onclick="exportToPDF()">üìÑ Export PDF avec Plan</button>
            </div>
        </div>
    </div>

    <script>

        let stockData = [];
        let lastOptimizationResult = null;
        let optimizationInProgress = false;

        function loadExample() {
            stockData = [
                {ref: "A1", family: "ELECTROFONDUS", quality: "AZS 33% RC", length: 1000, width: 400, thickness: 250, quantity: 20},
                {ref: "A2", family: "ELECTROFONDUS", quality: "AZS 36% RC", length: 1200, width: 500, thickness: 250, quantity: 15},
                {ref: "B1", family: "BAUXITE", quality: "85% AL2O3", length: 1500, width: 300, thickness: 250, quantity: 10},
                {ref: "B2", family: "BAUXITE", quality: "90% AL2O3", length: 800, width: 600, thickness: 250, quantity: 25},
                {ref: "C1", family: "SILICE", quality: "SiO2 96%", length: 2000, width: 400, thickness: 250, quantity: 8},
                {ref: "C2", family: "SILICE", quality: "SiO2 99%", length: 600, width: 700, thickness: 250, quantity: 12},
                {ref: "D1", family: "CARBURE", quality: "SiC 95%", length: 900, width: 450, thickness: 250, quantity: 18},
                {ref: "D2", family: "CARBURE", quality: "SiC 98%", length: 750, width: 550, thickness: 250, quantity: 22}
            ];
            updateFilters();
            updateStockDisplay();
            showStatus('success', '‚úÖ Exemple charg√© avec ' + stockData.length + ' casiers !');
        }

        function clearStock() {
            if (confirm('√ätes-vous s√ªr de vouloir vider le stock ?')) {
                stockData = [];
                updateFilters();
                updateStockDisplay();
                showStatus('warning', 'üóëÔ∏è Stock vid√©');
                document.getElementById('resultsSection').style.display = 'none';
                lastOptimizationResult = null;
            }
        }

        function showStatus(type, message) {
            const status = document.getElementById('importStatus');
            status.style.display = 'block';
            status.className = 'alert alert-' + type;
            status.textContent = message;
            
            // Auto-hide after 3 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }

        function updateFilters() {
            const familyFilter = document.getElementById('familyFilter');
            const qualityFilter = document.getElementById('qualityFilter');

            const families = [...new Set(stockData.map(item => item.family).filter(Boolean))].sort();
            const qualities = [...new Set(stockData.map(item => item.quality).filter(Boolean))].sort();

            const currentFamily = familyFilter.value;
            familyFilter.innerHTML = '<option value="">Toutes les familles</option>';
            families.forEach(family => {
                const option = document.createElement('option');
                option.value = family;
                option.textContent = family;
                if (family === currentFamily) option.selected = true;
                familyFilter.appendChild(option);
            });

            const currentQuality = qualityFilter.value;
            qualityFilter.innerHTML = '<option value="">Toutes les qualit√©s</option>';
            qualities.forEach(quality => {
                const option = document.createElement('option');
                option.value = quality;
                option.textContent = quality;
                if (quality === currentQuality) option.selected = true;
                qualityFilter.appendChild(option);
            });
        }

        function getFilteredStock() {
            const familyFilter = document.getElementById('familyFilter').value;
            const qualityFilter = document.getElementById('qualityFilter').value;

            let filtered = stockData.filter(item => {
                const familyMatch = !familyFilter || item.family === familyFilter;
                const qualityMatch = !qualityFilter || item.quality === qualityFilter;
                return familyMatch && qualityMatch;
            });

            const targetThickness = Number(document.getElementById('targetThickness').value);

            // Calculate scores for all items and sort by score
            filtered.forEach(item => {
                item.currentScore = item.thickness === targetThickness ? calculateBlockScore(item) : 0;
            });

            filtered.sort((a, b) => (b.currentScore || 0) - (a.currentScore || 0));

            return filtered;
        }

        function updateStockDisplay() {
            const tbody = document.getElementById('stockTableBody');
            const targetThickness = Number(document.getElementById('targetThickness').value);

            if (stockData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">Aucun stock charg√©</td></tr>';
                document.getElementById('stockCount').textContent = '0';
                document.getElementById('filteredCount').textContent = '0';
                return;
            }

            const filtered = getFilteredStock();
            let html = '';

            filtered.forEach(item => {
                const isCompatible = item.thickness === targetThickness;
                const score = item.currentScore || 0;
                const scoreColor = score >= 80 ? '#27ae60' : score >= 50 ? '#f39c12' : '#e74c3c';

                html += `<tr style="${!isCompatible ? 'opacity: 0.5;' : ''}">
                    <td style="font-weight: 600; color: #2980b9;">${item.ref}</td>
                    <td style="font-size: 0.8rem; color: #666;">${item.family || '-'}</td>
                    <td style="font-size: 0.8rem; color: #666;">${item.quality || '-'}</td>
                    <td>${item.length} mm</td>
                    <td>${item.width} mm</td>
                    <td style="color: ${isCompatible ? '#27ae60' : '#e74c3c'};">${item.thickness} mm</td>
                    <td style="color: ${isCompatible ? '#27ae60' : '#e74c3c'}; font-weight: 600;">${isCompatible ? '‚úÖ Oui' : '‚ùå Non'}</td>
                    <td style="color: ${isCompatible ? scoreColor : '#ccc'}; font-weight: 600;">${isCompatible ? score : '-'}</td>
                </tr>`;
            });

            const compatibleCount = filtered.filter(item => item.thickness === targetThickness).length;

            html += `<tr style="background: #f8f9fa; font-weight: 600; border-top: 2px solid #ddd;">
                <td>TOTAL</td>
                <td colspan="5">${filtered.length} casiers affich√©s (${compatibleCount} compatibles)</td>
                <td>-</td><td>-</td>
            </tr>`;

            tbody.innerHTML = html;
            document.getElementById('stockCount').textContent = stockData.length.toString();
            document.getElementById('filteredCount').textContent = filtered.length.toString();
        }

        function calculateBlockScore(block) {
            const targetLength = Number(document.getElementById('targetLength').value) || 3000;
            const targetWidth = Number(document.getElementById('targetWidth').value) || 2000;
            const numRows = Number(document.getElementById('numRows').value) || 3;

            const avgRowHeight = targetWidth / numRows;
            let score = 0;

            // Size score (0-50 points)
            const blockArea = block.length * block.width;
            const avgZoneArea = (targetLength / 3) * avgRowHeight;
            const sizeRatio = Math.min(blockArea / avgZoneArea, 2);
            score += Math.min(sizeRatio * 25, 50);

            // Height compatibility (0-30 points)
            const heightCompatibility = Math.min(block.width / avgRowHeight, 1);
            score += heightCompatibility * 30;

            // Proportion score (0-20 points)
            const ratio = Math.max(block.length, block.width) / Math.min(block.length, block.width);
            const proportionScore = Math.max(0, 1 - (ratio - 1) / 4);
            score += proportionScore * 20;

            return Math.round(score);
        }

        async function optimizeWall() {
            if (!stockData.length) {
                alert('Chargez d\'abord un stock !');
                return;
            }

            if (optimizationInProgress) {
                return;
            }

            optimizationInProgress = true;
            const targetLength = Number(document.getElementById('targetLength').value);
            const targetWidth = Number(document.getElementById('targetWidth').value);
            const targetThickness = Number(document.getElementById('targetThickness').value);
            const numRows = Number(document.getElementById('numRows').value);

            document.getElementById('resultsSection').style.display = 'block';
            document.getElementById('status').textContent = 'Optimisation avec jointures d√©cal√©es...';
            document.getElementById('status').className = 'alert alert-info';
            
            const progressContainer = document.getElementById('progressBarContainer');
            const progressFill = document.getElementById('progressFill');
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';

            try {
                // Simulate progress updates
                const progressSteps = [20, 40, 60, 80, 100];
                for (let i = 0; i < progressSteps.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    progressFill.style.width = progressSteps[i] + '%';
                }

                const result = optimizeWithJointConstraints(targetLength, targetWidth, targetThickness, numRows);
                lastOptimizationResult = result;
                displayResults(result);
            } catch (error) {
                showStatus('danger', '‚ùå Erreur lors de l\'optimisation: ' + error.message);
            } finally {
                optimizationInProgress = false;
                progressContainer.style.display = 'none';
            }
        }

        function optimizeWithJointConstraints(length, width, thickness, numRows) {
            const filtered = getFilteredStock();
            const available = filtered.filter(block => block.thickness === thickness);

            if (available.length === 0) {
                throw new Error('Aucun casier compatible avec l\'√©paisseur de ' + thickness + 'mm');
            }

            const targetRowHeight = width / numRows;
            const JOINT_OFFSET_MIN = Number(document.getElementById('jointOffset').value) || 50;
            const solution = [];
            let totalCuts = 0;
            let totalWasteVolume = 0;
            let currentY = 0;
            let actualRowCount = 0;
            let previousRowJoints = [];
            let totalJointViolations = 0;

            while (currentY < width && actualRowCount < numRows + 2) {
                const remainingHeight = width - currentY;
                let x = 0;
                let rowHeight = 0; // Hauteur fixe pour toute la rang√©e
                const currentRowJoints = [];
                const currentRowBlocks = []; // Stocker les blocs de la rang√©e

                // Premi√®re passe : d√©terminer la hauteur de la rang√©e
                let tempX = 0;
                while (tempX < length) {
                    const remainingLength = length - tempX;
                    let best = findBestBlockWithJointConstraints(
                        available, tempX, remainingLength, remainingHeight, 
                        targetRowHeight, thickness, previousRowJoints, JOINT_OFFSET_MIN
                    );

                    if (!best) {
                        best = findBestBlockIgnoringJoints(available, remainingLength, remainingHeight, targetRowHeight, thickness);
                        if (!best) break;
                    }

                    const useLength = Math.min(best.length, remainingLength);
                    const useWidth = Math.min(best.width, remainingHeight);
                    
                    // D√©terminer la hauteur maximale pour cette rang√©e
                    rowHeight = Math.max(rowHeight, useWidth);
                    
                    tempX += useLength;
                    if (tempX >= length) break;
                }

                // Si aucune hauteur n'a √©t√© d√©termin√©e, utiliser la hauteur cible
                if (rowHeight === 0) {
                    rowHeight = Math.min(targetRowHeight, remainingHeight);
                }

                // Deuxi√®me passe : placer les blocs avec la hauteur fixe de la rang√©e
                x = 0;
                while (x < length) {
                    const remainingLength = length - x;
                    let best = findBestBlockWithJointConstraints(
                        available, x, remainingLength, rowHeight, 
                        targetRowHeight, thickness, previousRowJoints, JOINT_OFFSET_MIN
                    );

                    if (!best) {
                        best = findBestBlockIgnoringJoints(available, remainingLength, rowHeight, targetRowHeight, thickness);
                        if (!best) break;
                        best.violatesJoints = true;
                        totalJointViolations++;
                    } else {
                        best.violatesJoints = false;
                    }

                    const useLength = Math.min(best.length, remainingLength);
                    const useWidth = rowHeight; // Utiliser la hauteur fixe de la rang√©e
                    let cuts = 0;
                    const cutDetails = [];
                    
                    if (best.length > useLength) {
                        cuts++;
                        cutDetails.push(`L:${best.length}‚Üí${useLength}`);
                    }
                    if (best.width > useWidth) {
                        cuts++;
                        cutDetails.push(`l:${best.width}‚Üí${useWidth}`);
                    }

                    const originalVolume = best.length * best.width * best.thickness;
                    const usedVolume = useLength * useWidth * thickness;
                    const wasteVolume = originalVolume - usedVolume;

                    const block = {
                        ref: best.ref,
                        family: best.family || 'N/A',
                        quality: best.quality || 'N/A',
                        x: x,
                        y: currentY,
                        width: useLength,
                        height: useWidth,
                        thickness: thickness,
                        cuts: cuts,
                        cutDetails: cutDetails,
                        wasteVolume: wasteVolume,
                        score: best.score || 0,
                        row: actualRowCount + 1,
                        violatesJoints: best.violatesJoints || false
                    };

                    solution.push(block);
                    totalCuts += cuts;
                    totalWasteVolume += wasteVolume;

                    const jointPosition = x + useLength;
                    if (jointPosition < length) {
                        currentRowJoints.push(jointPosition);
                    }

                    x += useLength;
                }

                if (x < length) {
                    const partialCoverage = solution.reduce((sum, block) => sum + block.width * block.height, 0) / (length * width) * 100;
                    return {
                        error: `Rang√©e ${actualRowCount + 1} incompl√®te`,
                        blocks: solution,
                        coverage: partialCoverage,
                        totalCuts: totalCuts,
                        totalWasteVolume: totalWasteVolume,
                        wallVolume: length * width * thickness,
                        numRows: actualRowCount + 1,
                        jointViolations: totalJointViolations
                    };
                }

                previousRowJoints = [...currentRowJoints];
                currentY += rowHeight;
                actualRowCount++;
            }

            if (currentY < width) {
                const partialCoverage = solution.reduce((sum, block) => sum + block.width * block.height, 0) / (length * width) * 100;
                return {
                    error: `Couverture partielle: ${Math.round((currentY / width) * 100)}%`,
                    blocks: solution,
                    coverage: partialCoverage,
                    totalCuts: totalCuts,
                    totalWasteVolume: totalWasteVolume,
                    wallVolume: length * width * thickness,
                    numRows: actualRowCount,
                    jointViolations: totalJointViolations
                };
            }

            const wallVolume = length * width * thickness;
            const efficiency = (wallVolume / (wallVolume + totalWasteVolume)) * 100;

            return {
                blocks: solution,
                coverage: 100,
                totalCuts: totalCuts,
                totalWasteVolume: totalWasteVolume,
                wallVolume: wallVolume,
                efficiency: Math.round(efficiency * 10) / 10,
                numRows: actualRowCount,
                targetRows: numRows,
                jointViolations: totalJointViolations
            };
        }
        function enrichBlocksWithOriginalDimensions(blocks, stockData) {
    return blocks.map(block => {
        // Trouver le casier original dans le stock
        const originalStock = stockData.find(stock => stock.ref === block.ref);
        
        if (originalStock) {
            return {
                ...block,
                originalLength: originalStock.length,
                originalWidth: originalStock.width,
                thickness: originalStock.thickness || block.thickness
            };
        }
        
        return block;
    });
}

        function findBestBlockWithJointConstraints(blocks, currentX, maxLength, maxHeight, targetHeight, targetThickness, forbiddenJoints, minOffset) {
            let bestBlock = null;
            let bestScore = -1;

            for (const block of blocks) {
                if (block.thickness !== targetThickness) continue;
                if (block.length < 1 || block.width < 1) continue;

                const useLength = Math.min(block.length, maxLength);
                const useWidth = Math.min(block.width, maxHeight);
                const jointPosition = currentX + useLength;

                // Check joint violations
                let violatesJoints = false;
                for (const joint of forbiddenJoints) {
                    const distance = Math.abs(jointPosition - joint);
                    if (distance < minOffset) {
                        violatesJoints = true;
                        break;
                    }
                }

                if (violatesJoints) continue;

                const coverage = useLength * useWidth;
                const maxCoverage = maxLength * maxHeight;
                const lengthRatio = useLength / maxLength;
                const heightDiff = Math.abs(useWidth - targetHeight);
                const heightScore = Math.max(0, 20 - (heightDiff / targetHeight) * 20);
                const efficiency = coverage / (block.length * block.width);
                let cuts = 0;
                if (block.length > useLength) cuts++;
                if (block.width > useWidth) cuts++;

                const score = (coverage / maxCoverage) * 40 + lengthRatio * 30 + heightScore + efficiency * 10 - cuts * 3;

                if (score > bestScore) {
                    bestScore = score;
                    bestBlock = { ...block, score: Math.round(score) };
                }
            }

            return bestBlock;
        }

        function findBestBlockIgnoringJoints(blocks, maxLength, maxHeight, targetHeight, targetThickness) {
            let bestBlock = null;
            let bestScore = -1;

            for (const block of blocks) {
                if (block.thickness !== targetThickness) continue;
                if (block.length < 1 || block.width < 1) continue;

                const useLength = Math.min(block.length, maxLength);
                const useWidth = Math.min(block.width, maxHeight);

                const coverage = useLength * useWidth;
                const maxCoverage = maxLength * maxHeight;
                const lengthRatio = useLength / maxLength;
                const heightDiff = Math.abs(useWidth - targetHeight);
                const heightScore = Math.max(0, 20 - (heightDiff / targetHeight) * 20);
                const efficiency = coverage / (block.length * block.width);
                let cuts = 0;
                if (block.length > useLength) cuts++;
                if (block.width > useWidth) cuts++;

                const score = (coverage / maxCoverage) * 40 + lengthRatio * 30 + heightScore + efficiency * 10 - cuts * 3;

                if (score > bestScore) {
                    bestScore = score;
                    bestBlock = { ...block, score: Math.round(score) };
                }
            }

            return bestBlock;
        }

        function calculateRealCoverage(blocks, targetLength, targetWidth) {
            if (!blocks || blocks.length === 0) return 0;

            const gridResolution = 10;
            const gridWidth = Math.ceil(targetLength / gridResolution);
            const gridHeight = Math.ceil(targetWidth / gridResolution);

            const grid = Array(gridHeight).fill().map(() => Array(gridWidth).fill(false));

            blocks.forEach(block => {
                const startX = Math.floor(block.x / gridResolution);
                const endX = Math.min(gridWidth - 1, Math.floor((block.x + block.width) / gridResolution));
                const startY = Math.floor(block.y / gridResolution);
                const endY = Math.min(gridHeight - 1, Math.floor((block.y + block.height) / gridResolution));

                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        grid[y][x] = true;
                    }
                }
            });

            let coveredPoints = 0;
            let totalPoints = 0;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const realX = x * gridResolution;
                    const realY = y * gridResolution;

                    if (realX < targetLength && realY < targetWidth) {
                        totalPoints++;
                        if (grid[y][x]) {
                            coveredPoints++;
                        }
                    }
                }
            }

            return totalPoints > 0 ? Math.round((coveredPoints / totalPoints) * 1000) / 10 : 0;
        }

        function displayResults(result) {
            const targetLength = Number(document.getElementById('targetLength').value);
            const targetWidth = Number(document.getElementById('targetWidth').value);
            const realCoverage = calculateRealCoverage(result.blocks, targetLength, targetWidth);

            let statusMessage = '';
            let statusClass = '';

            if (result.error) {
                statusClass = 'alert alert-danger';
                statusMessage = '‚ùå ' + result.error;
            } else if (realCoverage >= 100) {
                const adaptation = result.targetRows ?
                    (result.numRows === result.targetRows ?
                        result.numRows + ' rang√©es' :
                        result.numRows + ' rang√©es (pr√©vu: ' + result.targetRows + ')') :
                    result.numRows + ' rang√©es';

                if (result.jointViolations && result.jointViolations > 0) {
                    statusMessage = `‚ö†Ô∏è Mur couvert avec ${adaptation} mais ${result.jointViolations} violations de jointures`;
                    statusClass = 'alert alert-warning';
                } else {
                    statusMessage = `‚úÖ Mur parfaitement couvert avec ${adaptation} et jointures d√©cal√©es ! Efficacit√©: ${result.efficiency}%`;
                    statusClass = 'alert alert-success';
                }
            } else if (realCoverage >= 95) {
                statusMessage = `‚ö†Ô∏è Couverture ${realCoverage}% - Adaptation incompl√®te`;
                statusClass = 'alert alert-warning';
            } else {
                statusMessage = `‚ùå Couverture ${realCoverage}% - √âchec d\'optimisation`;
                statusClass = 'alert alert-danger';
            }

            document.getElementById('status').textContent = statusMessage;
            document.getElementById('status').className = statusClass;

            updateStats(result);
            visualizeWall(result.blocks);
            displayBlocksList(result.blocks);
        }

        function updateStats(result) {
            const targetLength = Number(document.getElementById('targetLength').value);
            const targetWidth = Number(document.getElementById('targetWidth').value);
            const realCoverage = calculateRealCoverage(result.blocks, targetLength, targetWidth);

            document.getElementById('blocksUsed').textContent = result.blocks.length;
            document.getElementById('cutsNeeded').textContent = result.totalCuts;
            document.getElementById('jointViolations').textContent = result.jointViolations || 0;
            document.getElementById('coverage').textContent = realCoverage + '%';
            document.getElementById('wasteVolume').textContent = Math.round(result.totalWasteVolume).toLocaleString() + ' mm¬≥';
            document.getElementById('wallVolume').textContent = Math.round(result.wallVolume).toLocaleString() + ' mm¬≥';
            document.getElementById('rowsCreated').textContent = result.numRows + (result.targetRows ? ' (cible: ' + result.targetRows + ')' : '');
            document.getElementById('efficiency').textContent = (result.efficiency || 0) + '%';
        }

        function visualizeWall(blocks) {
            const container = document.getElementById('wallBlocks');
            container.innerHTML = '';

            const targetLength = Number(document.getElementById('targetLength').value);
            const targetWidth = Number(document.getElementById('targetWidth').value);

            const containerWidth = 280;
            const containerHeight = 250;
            const scaleX = containerWidth / targetLength;
            const scaleY = containerHeight / targetWidth;
            const scale = Math.min(scaleX, scaleY) * 0.8;

            const offsetX = 20;
            const offsetY = 20;

            // Wall outline
            const wallRect = document.createElement('div');
            wallRect.style.cssText = `position: absolute; left: ${offsetX}px; top: ${offsetY}px; 
                width: ${targetLength * scale}px; height: ${targetWidth * scale}px; 
                border: 3px solid #e74c3c; background: rgba(255, 235, 238, 0.8); 
                z-index: 1; box-shadow: 0 2px 8px rgba(0,0,0,0.15);`;
            wallRect.title = `Mur cible: ${targetLength}√ó${targetWidth}mm`;
            container.appendChild(wallRect);

            if (blocks && blocks.length > 0) {
                const rowsJoints = {};

                // Draw blocks
                blocks.forEach(block => {
                    const blockDiv = document.createElement('div');
                    blockDiv.className = 'block';
                    blockDiv.style.left = (offsetX + block.x * scale) + 'px';
                    blockDiv.style.top = (offsetY + block.y * scale) + 'px';
                    blockDiv.style.width = (block.width * scale) + 'px';
                    blockDiv.style.height = (block.height * scale) + 'px';
                    blockDiv.style.zIndex = '2';

                    let hue;
                    if (block.violatesJoints) {
                        hue = 0; // Red for violations
                    } else if (block.cuts === 0) {
                        hue = 120; // Green for no cuts
                    } else if (block.cuts <= 2) {
                        hue = 60; // Yellow for few cuts
                    } else {
                        hue = 30; // Orange for many cuts
                    }

                    blockDiv.style.background = `hsl(${hue}, 70%, 50%)`;
                    blockDiv.style.border = block.violatesJoints ? '2px solid #c0392b' : '1px solid #333';
                    blockDiv.textContent = block.ref;

                    const jointStatus = block.violatesJoints ? '\n‚ö†Ô∏è VIOLE JOINTURES' : '\n‚úÖ JOINTURES OK';
                    blockDiv.title = `${block.ref} - Rang√©e ${block.row}\n${block.width}√ó${block.height}√ó${block.thickness}mm\nPosition: (${block.x}, ${block.y})\nD√©coupes: ${block.cuts}${jointStatus}`;
                    
                    container.appendChild(blockDiv);

                    // Collect joint positions
                    if (!rowsJoints[block.row]) {
                        rowsJoints[block.row] = [];
                    }
                    const jointX = block.x + block.width;
                    if (jointX < targetLength) {
                        rowsJoints[block.row].push({
                            x: jointX,
                            y: block.y,
                            height: block.height,
                            violates: block.violatesJoints
                        });
                    }
                });

                // Draw joint lines
                Object.entries(rowsJoints).forEach(([rowNum, joints]) => {
                    joints.forEach(joint => {
                        const jointLine = document.createElement('div');
                        jointLine.style.cssText = `position: absolute; left: ${offsetX + joint.x * scale - 1}px; 
                            top: ${offsetY + joint.y * scale}px; width: 2px; height: ${joint.height * scale}px; 
                            background: ${joint.violates ? '#e74c3c' : '#2c3e50'}; z-index: 3; opacity: 0.8;`;
                        jointLine.title = `Jointure rang√©e ${rowNum} √† X=${joint.x}mm${joint.violates ? ' (VIOLE CONTRAINTE)' : ''}`;
                        container.appendChild(jointLine);
                    });
                });
            }

            // Coverage display
            const realCoverage = calculateRealCoverage(blocks, targetLength, targetWidth);
            const coverageDisplay = document.getElementById('coverageDisplay');
            coverageDisplay.textContent = realCoverage + '%';
            coverageDisplay.style.background = realCoverage >= 100 ? '#27ae60' : realCoverage >= 95 ? '#f39c12' : '#e74c3c';

            // Dimensions label
            const dimensions = document.createElement('div');
            dimensions.style.cssText = `position: absolute; top: ${offsetY - 20}px; left: ${offsetX}px; 
                font-size: 12px; font-weight: 600; color: #2c3e50; z-index: 3;`;
            dimensions.textContent = `${targetLength} √ó ${targetWidth} mm`;
            container.appendChild(dimensions);

            // Legend
            const legend = document.createElement('div');
            legend.style.cssText = `position: absolute; bottom: 5px; left: 5px; font-size: 10px; 
                color: #666; z-index: 3; background: rgba(255,255,255,0.9); padding: 5px; border-radius: 3px;`;
            legend.innerHTML = `<div><strong>Jointures d√©cal√©es (min ${document.getElementById('jointOffset').value}mm)</strong></div>
                <div>üü¢ Sans d√©coupe ‚Ä¢ üü° 1-2 d√©coupes ‚Ä¢ üü† 3+ d√©coupes</div>
                <div>üî¥ Viole contraintes jointures</div>
                <div>‚îÅ Lignes de jointures (noires=OK, rouges=violations)</div>`;
            container.appendChild(legend);

            // Mouse tracking
            setupMouseTracking(container, targetLength, targetWidth, offsetX, offsetY, scale);
        }

        function setupMouseTracking(container, targetLength, targetWidth, offsetX, offsetY, scale) {
            const cursor = document.getElementById('cursor');
            const coordinates = document.getElementById('coordinates');

            container.addEventListener('mousemove', function(e) {
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const x = (mouseX - offsetX) / scale;
                const y = (mouseY - offsetY) / scale;

                if (x >= 0 && x <= targetLength && y >= 0 && y <= targetWidth) {
                    cursor.style.left = mouseX + 'px';
                    cursor.style.top = mouseY + 'px';
                    cursor.style.display = 'block';
                    coordinates.textContent = `X: ${Math.round(x)}, Y: ${Math.round(y)}`;
                } else {
                    cursor.style.display = 'none';
                }
            });

            container.addEventListener('mouseleave', function() {
                cursor.style.display = 'none';
            });
        }

        // ========================================
// MODIFICATION DE LA FONCTION displayBlocksList
// Cette fonction remplace votre fonction displayBlocksList existante
// ========================================

function displayBlocksList(blocks) {
    const container = document.getElementById('blocksList');
    const groups = {};

    // Grouper les blocs par r√©f√©rence
    blocks.forEach(block => {
        if (!groups[block.ref]) {
            groups[block.ref] = {
                count: 0,
                cuts: 0,
                waste: 0,
                rows: [],
                family: block.family || 'N/A',
                quality: block.quality || 'N/A',
                violations: 0,
                hasCuts: false,
                cutDetails: []
            };
        }
        groups[block.ref].count++;
        groups[block.ref].cuts += block.cuts;
        groups[block.ref].waste += block.wasteVolume;
        if (block.row && !groups[block.ref].rows.includes(block.row)) {
            groups[block.ref].rows.push(block.row);
        }
        if (block.violatesJoints) groups[block.ref].violations++;
        
        // D√©tail des d√©coupes pour ce bloc
        if (block.cuts > 0) {
            groups[block.ref].hasCuts = true;
            const hasLengthCut = block.originalLength && block.width < block.originalLength;
            const hasWidthCut = block.originalWidth && block.height < block.originalWidth;
            
            groups[block.ref].cutDetails.push({
                original: `${block.originalLength || 0}√ó${block.originalWidth || 0}`,
                used: `${block.width}√ó${block.height}`,
                type: hasLengthCut && hasWidthCut ? 'L+l' : hasLengthCut ? 'L' : 'l'
            });
        }
    });

    let html = '';
    Object.entries(groups).forEach(([ref, data]) => {
        const rowsList = data.rows.sort((a, b) => a - b).join(', ');
        const violationText = data.violations > 0 ?
            ` ‚Ä¢ ‚ö†Ô∏è ${data.violations} violations jointures` :
            ' ‚Ä¢ ‚úÖ Jointures OK';

        // D√©tail des d√©coupes pour ce casier
        const cutDetailsText = data.hasCuts ? 
            ` ‚Ä¢ D√©coupes: ${data.cutDetails.map(c => `${c.original}‚Üí${c.used}(${c.type})`).join(', ')}` : 
            ' ‚Ä¢ Bloc entier';

        const itemStyle = data.violations > 0 ?
            'padding: 8px; border-bottom: 1px solid #ddd; background: #fff3cd; margin-bottom: 3px; border-left: 3px solid #ffc107;' :
            'padding: 8px; border-bottom: 1px solid #ddd; background: #f9f9f9; margin-bottom: 3px;';

        html += `<div style="${itemStyle}">
            <div style="display: flex; justify-content: space-between;"><strong>${ref}</strong><span>√ó${data.count}</span></div>
            <div style="font-size: 0.8rem; color: #666;">${data.family} ‚Ä¢ ${data.quality}</div>
            <div style="font-size: 0.8rem; color: #666;">Rang√©es: ${rowsList}${cutDetailsText}</div>
            <div style="font-size: 0.8rem; color: #666;">D√©coupes: ${data.cuts} ‚Ä¢ Chutes: ${Math.round(data.waste)} mm¬≥${violationText}</div>
        </div>`;
    });

    container.innerHTML = html;

    // Ajouter le bouton pour voir les d√©tails des d√©coupes
    const detailButton = document.createElement('button');
    detailButton.style.cssText = `
        width: 100%; margin-top: 10px; padding: 8px; 
        background: #3498db; color: white; border: none; 
        border-radius: 5px; cursor: pointer; font-size: 0.9rem;
    `;
    detailButton.textContent = '‚úÇÔ∏è Voir D√©tail des D√©coupes';
    detailButton.onclick = showCuttingDetails;
    container.appendChild(detailButton);

    // Summary existant (votre code)
    const totalWaste = Object.values(groups).reduce((sum, data) => sum + data.waste, 0);
    const totalCuts = Object.values(groups).reduce((sum, data) => sum + data.cuts, 0);
    const totalViolations = Object.values(groups).reduce((sum, data) => sum + data.violations, 0);
    const families = [...new Set(Object.values(groups).map(data => data.family))];

    const summary = document.createElement('div');
    const summaryColor = totalViolations > 0 ? '#ffc107' : '#27ae60';
    summary.style.cssText = `margin-top: 10px; padding: 10px; background: ${summaryColor}; 
        color: white; border-radius: 6px; text-align: center;`;

    const jointStatus = totalViolations === 0 ?
        '‚úÖ JOINTURES PARFAITES' :
        `‚ö†Ô∏è ${totalViolations} VIOLATIONS JOINTURES`;

    const minOffset = document.getElementById('jointOffset').value;
    summary.innerHTML = `<strong>${jointStatus}</strong><br>
        <div style="margin-top: 5px; font-size: 0.9rem;">
            ${Object.keys(groups).length} casiers ‚Ä¢ ${blocks.length} blocs total<br>
            ${families.length} familles ‚Ä¢ ${totalCuts} d√©coupes ‚Ä¢ ${Math.round(totalWaste)} mm¬≥ chutes<br>
            <small>D√©calage minimum: ${minOffset}mm entre rang√©es adjacentes</small>
        </div>`;
    container.appendChild(summary);
}

console.log('‚úÖ Syst√®me de d√©tail des d√©coupes ajout√©');

        function exportToPDF() {
            if (!lastOptimizationResult || !lastOptimizationResult.blocks) {
                alert('Aucun r√©sultat √† exporter. Lancez d\'abord une optimisation.');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const targetLength = Number(document.getElementById('targetLength').value);
            const targetWidth = Number(document.getElementById('targetWidth').value);
            const targetThickness = Number(document.getElementById('targetThickness').value);
            const realCoverage = calculateRealCoverage(lastOptimizationResult.blocks, targetLength, targetWidth);
            
            // Header
            doc.setFontSize(18);
            doc.text('Rapport d\'Optimisation - Mur R√©fractaire', 20, 20);

            doc.setFontSize(12);
            const date = new Date().toLocaleDateString('fr-FR');
            doc.text('G√©n√©r√© le ' + date, 20, 30);

            // Configuration
            doc.setFontSize(14);
            doc.text('Configuration du Mur', 20, 50);
            doc.setFontSize(12);
            doc.text(`Dimensions: ${targetLength} √ó ${targetWidth} √ó ${targetThickness} mm`, 20, 60);

            // Results
            doc.setFontSize(14);
            doc.text('R√©sultats avec Jointures D√©cal√©es', 20, 90);
            doc.setFontSize(12);
            doc.text(`Couverture: ${realCoverage}%`, 20, 100);
            doc.text(`Efficacit√©: ${lastOptimizationResult.efficiency || 'N/A'}%`, 20, 110);
            doc.text(`Casiers utilis√©s: ${lastOptimizationResult.blocks.length}`, 20, 120);
            doc.text(`Rang√©es cr√©√©es: ${lastOptimizationResult.numRows}`, 20, 130);
            doc.text(`D√©coupes totales: ${lastOptimizationResult.totalCuts}`, 20, 140);
            doc.text(`Violations de jointures: ${lastOptimizationResult.jointViolations || 0}`, 20, 150);

            // New page for wall plan
            doc.addPage();
            doc.setFontSize(16);
            doc.text('Plan de Disposition des Blocs', 20, 20);

            // Draw wall plan
            const planStartX = 20;
            const planStartY = 40;
            const planMaxWidth = 170;
            const planMaxHeight = 200;

            const scaleX = planMaxWidth / targetLength;
            const scaleY = planMaxHeight / targetWidth;
            const scale = Math.min(scaleX, scaleY);

            const planWidth = targetLength * scale;
            const planHeight = targetWidth * scale;

            // Wall outline
            doc.setDrawColor(255, 0, 0);
            doc.setLineWidth(1);
            doc.rect(planStartX, planStartY, planWidth, planHeight);

            // Dimensions
            doc.setFontSize(10);
            doc.text(`${targetLength}mm`, planStartX + planWidth/2 - 10, planStartY - 5);
            doc.text(`${targetWidth}mm`, planStartX - 15, planStartY + planHeight/2);

            // Draw blocks
            const colors = ['#27ae60', '#f39c12', '#e74c3c', '#3498db', '#9b59b6', '#1abc9c'];
            const familyColors = {};
            let colorIndex = 0;

            lastOptimizationResult.blocks.forEach(block => {
                if (!familyColors[block.family]) {
                    familyColors[block.family] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const blockX = planStartX + (block.x * scale);
                const blockY = planStartY + (block.y * scale);
                const blockWidth = block.width * scale;
                const blockHeight = block.height * scale;

                doc.setFillColor(familyColors[block.family] || '#95a5a6');
                doc.setDrawColor(0, 0, 0);
                doc.setLineWidth(0.2);
                doc.rect(blockX, blockY, blockWidth, blockHeight, 'FD');

                if (blockWidth > 15 && blockHeight > 8) {
                    doc.setFontSize(8);
                    doc.setTextColor(255, 255, 255);
                    const textX = blockX + blockWidth/2;
                    const textY = blockY + blockHeight/2 + 2;
                    doc.text(block.ref, textX, textY, { align: 'center' });
                }
            });

            // Legend
            let legendY = planStartY + planHeight + 20;
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            doc.text('L√©gende des Familles:', 20, legendY);
            
            legendY += 10;
            Object.entries(familyColors).forEach(([family, color]) => {
                doc.setFillColor(color);
                doc.rect(20, legendY - 3, 8, 6, 'F');
                doc.setFontSize(10);
                doc.text(family, 32, legendY + 1);
                legendY += 10;
            });
		 // Nouvelle page pour les d√©tails des casiers
            doc.addPage();
            doc.setFontSize(16);
            doc.text('D√©tail des Casiers Utilis√©s', 20, 20);
            doc.setFontSize(10);

            const groups = {};
            lastOptimizationResult.blocks.forEach(block => {
                if (!groups[block.ref]) {
                    groups[block.ref] = {
                        count: 0, 
                        cuts: 0, 
                        waste: 0, 
                        rows: new Set(),
                        family: block.family || 'N/A',
                        quality: block.quality || 'N/A'
                    };
                }
                groups[block.ref].count++;
                groups[block.ref].cuts += block.cuts;
                groups[block.ref].waste += block.wasteVolume;
                groups[block.ref].rows.add(block.row);
            });

            let yPos = 40;
            doc.text('Casier | Famille | Qualit√© | Qt√© | Rang√©es | D√©coupes | Chutes (mm¬≥)', 20, yPos);
            yPos += 5;
            doc.line(20, yPos, 190, yPos);
            yPos += 10;

            Object.entries(groups).forEach(([ref, data]) => {
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 20;
                }
                const rowsList = Array.from(data.rows).sort().join(', ');
                const wasteVolume = Math.round(data.waste);
                const line = `${ref} | ${data.family} | ${data.quality} | x${data.count} | ${rowsList} | ${data.cuts} | ${wasteVolume} mm¬≥`;
                doc.text(line, 20, yPos);
                yPos += 8;
            });
            doc.save(`optimisation_mur_jointures_${targetLength}x${targetWidth}x${targetThickness}_${date.replace(/\//g, '-')}.pdf`);
        }

        function exportToCSV() {
            // Function removed as requested
        }

        // Event listeners
        ['targetLength', 'targetWidth', 'targetThickness', 'numRows', 'jointOffset'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', updateStockDisplay);
            }
        });

        ['familyFilter', 'qualityFilter'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', updateStockDisplay);
            }
        });

        // Excel file import
        const excelFileInput = document.getElementById('excelFile');
        if (excelFileInput) {
            excelFileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                showStatus('info', 'Import en cours...');

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const rows = XLSX.utils.sheet_to_json(sheet, {header: 1});

                        stockData = parseStockData(rows);
                        updateFilters();
                        updateStockDisplay();

                        showStatus('success', `‚úÖ ${stockData.length} casiers import√©s avec succ√®s`);
                    } catch (error) {
                        showStatus('danger', `‚ùå Erreur d'import: ${error.message}`);
                        console.error('Import error:', error);
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function parseStockData(rows) {
            if (rows.length < 4) throw new Error('Fichier vide ou structure incorrecte');

            let headerRowIndex = -1;
            for (let i = 0; i < rows.length; i++) {
                if (rows[i] && Array.isArray(rows[i])) {
                    for (let j = 0; j < rows[i].length; j++) {
                        const cell = rows[i][j];
                        if (cell && String(cell).toUpperCase().includes('CASIER')) {
                            headerRowIndex = i;
                            break;
                        }
                    }
                    if (headerRowIndex >= 0) break;
                }
            }

            if (headerRowIndex === -1) throw new Error('En-t√™tes non trouv√©s');

            const headers = [];
            for (let i = 0; i < rows[headerRowIndex].length; i++) {
                headers[i] = String(rows[headerRowIndex][i] || '').toUpperCase();
            }

            function findCol(names) {
                for (let i = 0; i < names.length; i++) {
                    for (let j = 0; j < headers.length; j++) {
                        if (headers[j] && headers[j].includes(names[i])) {
                            return j;
                        }
                    }
                }
                return -1;
            }

            const columnMap = {
                ref: findCol(['CASIER']),
                family: findCol(['FAMILLE']),
                quality: findCol(['QUALIT√â', 'QUALITE']),
                length: findCol(['LONGUEUR']),
                width: findCol(['LARGEUR']),
                thickness: findCol(['√âPAISSEUR', 'EPAISSEUR']),
                quantity: findCol(['STOCK'])
            };

            const missing = [];
            for (const key in columnMap) {
                if (columnMap[key] === -1 && key !== 'quantity') {
                    missing.push(key);
                }
            }
            if (missing.length) throw new Error('Colonnes manquantes: ' + missing.join(', '));

            const parsedData = [];
            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i];
                if (!row || !Array.isArray(row) || row.length === 0) continue;

                try {
                    const item = {
                        ref: String(row[columnMap.ref] || '').trim(),
                        family: String(row[columnMap.family] || '').trim(),
                        quality: String(row[columnMap.quality] || '').trim(),
                        length: Number(row[columnMap.length]) || 0,
                        width: Number(row[columnMap.width]) || 0,
                        thickness: Number(row[columnMap.thickness]) || 0,
                        quantity: columnMap.quantity >= 0 ? Number(row[columnMap.quantity]) || 0 : 999
                    };

                    if (item.ref && item.length > 0 && item.width > 0 && item.thickness > 0) {
                        parsedData.push(item);
                    }
                } catch (error) {
                    console.warn('Erreur ligne ' + (i + 1) + ':', error);
                }
            }

            console.log(parsedData.length + ' articles valides trouv√©s');
            return parsedData;
        }

        // Initialize interface
        function initializeInterface() {
            updateStockDisplay();
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'Enter':
                            e.preventDefault();
                            optimizeWall();
                            break;
                        case 'r':
                            e.preventDefault();
                            if (lastOptimizationResult) {
                                displayResults(lastOptimizationResult);
                            }
                            break;
                    }
                }
            });

            // Add input validation
            const numberInputs = ['targetLength', 'targetWidth', 'targetThickness', 'numRows', 'jointOffset'];
            numberInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('blur', function() {
                        const min = parseFloat(this.min) || 0;
                        const max = parseFloat(this.max) || Infinity;
                        let value = parseFloat(this.value) || min;
                        
                        if (value < min) value = min;
                        if (value > max) value = max;
                        
                        this.value = value;
                        updateStockDisplay();
                    });
                }
            });

            console.log('üéØ Optimisateur de Murs R√©fractaires - Version Am√©lior√©e');
            console.log('‚úÖ Contraintes de jointures param√©trables');
            console.log('‚úÖ Interface utilisateur am√©lior√©e');
            console.log('‚úÖ Export PDF');
            console.log('‚úÖ Validation des donn√©es renforc√©e');
            console.log('‚úÖ Suivi de souris avec coordonn√©es');
            console.log('Raccourcis: Ctrl+Enter pour optimiser, Ctrl+R pour rafra√Æchir');
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeInterface();
        });
    </script>
<script>
    // ========================================
// VERSION SIMPLIFI√âE - SANS FEEDBACKS NI RACCOURCIS
// Remplacez TOUT votre code de collecte de donn√©es par celui-ci
// ========================================

class SimpleOptimizationTracker {
    constructor() {
        this.init();
    }

    async init() {
        try {
            // Utiliser localStorage simple pour √©viter les complications
            console.log('‚úÖ Syst√®me de collecte simple initialis√©');
        } catch (error) {
            console.error('‚ùå Erreur initialisation:', error);
        }
    }

    saveOptimization(wallConfig, result, stockData, optimizationTime) {
        try {
            const projects = JSON.parse(localStorage.getItem('wall_projects') || '[]');
            
            const projectData = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                wallConfig: wallConfig,
                result: {
                    coverage: result.coverage || 0,
                    efficiency: result.efficiency || 0,
                    totalCuts: result.totalCuts || 0,
                    jointViolations: result.jointViolations || 0,
                    numRows: result.numRows || 0,
                    wallVolume: result.wallVolume || 0,
                    totalWasteVolume: result.totalWasteVolume || 0
                },
                optimizationTime: optimizationTime,
                blocks: result.blocks || [],
                stockData: stockData || []
            };

            projects.push(projectData);
            
            // Garder seulement les 30 derniers projets
            if (projects.length > 30) {
                projects.splice(0, projects.length - 30);
            }

            localStorage.setItem('wall_projects', JSON.stringify(projects));
            console.log(`‚úÖ Optimisation sauvegard√©e (${projects.length} projets total)`);
            
            return projectData.id;

        } catch (error) {
            console.error('‚ùå Erreur sauvegarde:', error);
            return null;
        }
    }

    getStats() {
        try {
            const projects = JSON.parse(localStorage.getItem('wall_projects') || '[]');
            
            if (!projects.length) {
                return { error: 'Aucun projet trouv√©' };
            }

            const stats = {
                totalProjects: projects.length,
                avgCoverage: projects.reduce((sum, p) => sum + (p.result?.coverage || 0), 0) / projects.length,
                avgEfficiency: projects.reduce((sum, p) => sum + (p.result?.efficiency || 0), 0) / projects.length,
                avgCuts: projects.reduce((sum, p) => sum + (p.result?.totalCuts || 0), 0) / projects.length,
                avgViolations: projects.reduce((sum, p) => sum + (p.result?.jointViolations || 0), 0) / projects.length,
                avgTime: projects.reduce((sum, p) => sum + (p.optimizationTime || 0), 0) / projects.length
            };

            // Statistiques par famille
            const familyStats = {};
            projects.forEach(project => {
                (project.blocks || []).forEach(block => {
                    const family = block.family || 'N/A';
                    if (!familyStats[family]) {
                        familyStats[family] = { count: 0, totalWaste: 0 };
                    }
                    familyStats[family].count++;
                    familyStats[family].totalWaste += block.wasteVolume || 0;
                });
            });

            stats.topFamilies = Object.entries(familyStats)
                .map(([family, data]) => ({
                    family,
                    count: data.count,
                    avgWaste: data.totalWaste / data.count
                }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);

            return stats;

        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration stats:', error);
            return { error: 'Erreur lors du calcul des statistiques' };
        }
    }

    exportData() {
        try {
            const projects = JSON.parse(localStorage.getItem('wall_projects') || '[]');
            
            const exportData = {
                projects: projects,
                exportDate: new Date().toISOString(),
                version: '1.0',
                totalProjects: projects.length
            };

            // Cr√©er et t√©l√©charger le fichier JSON
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `optimisation_donnees_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            console.log('‚úÖ Export termin√©');
            return true;

        } catch (error) {
            console.error('‚ùå Erreur export:', error);
            return false;
        }
    }

    getSuggestions() {
        const stats = this.getStats();
        const suggestions = [];

        if (stats.error) {
            suggestions.push("üìä Pas encore de donn√©es collect√©es");
            return suggestions;
        }

        if (stats.totalProjects < 5) {
            suggestions.push("üìà Collectez plus de donn√©es pour des analyses pertinentes");
        }

        if (stats.avgCoverage < 95) {
            suggestions.push("üéØ Couverture moyenne: " + stats.avgCoverage.toFixed(1) + "% - Peut √™tre am√©lior√©e");
        }

        if (stats.avgEfficiency < 80) {
            suggestions.push("‚ö° Efficacit√© moyenne: " + stats.avgEfficiency.toFixed(1) + "% - Analysez les d√©coupes");
        }

        if (stats.avgViolations > 1) {
            suggestions.push("üîó Violations moyennes: " + stats.avgViolations.toFixed(1) + " - Ajustez les jointures");
        }

        if (suggestions.length === 0) {
            suggestions.push("‚úÖ Bonnes performances g√©n√©rales !");
        }

        return suggestions;
    }
}

// Initialiser le tracker simple
const simpleTracker = new SimpleOptimizationTracker();

// ========================================
// FONCTION D'OPTIMISATION MODIFI√âE (SANS FEEDBACKS)
// ========================================

async function optimizeWallSimple() {
    if (!stockData.length) {
        alert('Chargez d\'abord un stock !');
        return;
    }

    if (optimizationInProgress) {
        return;
    }

    optimizationInProgress = true;
    
    const startTime = performance.now();
    
    const wallConfig = {
        length: Number(document.getElementById('targetLength').value),
        width: Number(document.getElementById('targetWidth').value),
        thickness: Number(document.getElementById('targetThickness').value),
        numRows: Number(document.getElementById('numRows').value),
        jointOffset: Number(document.getElementById('jointOffset').value)
    };

    document.getElementById('resultsSection').style.display = 'block';
    document.getElementById('status').textContent = 'Optimisation avec jointures d√©cal√©es...';
    document.getElementById('status').className = 'alert alert-info';
    
    const progressContainer = document.getElementById('progressBarContainer');
    const progressFill = document.getElementById('progressFill');
    progressContainer.style.display = 'block';
    progressFill.style.width = '0%';

    try {
        // Simuler les √©tapes de progression
        const progressSteps = [20, 40, 60, 80, 100];
        for (let i = 0; i < progressSteps.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 200));
            progressFill.style.width = progressSteps[i] + '%';
        }

        // Ex√©cuter l'algorithme d'optimisation
        const result = optimizeWithJointConstraints(
            wallConfig.length, 
            wallConfig.width, 
            wallConfig.thickness, 
            wallConfig.numRows
        );
        
        // ‚≠ê NOUVEAU: Enrichir les blocs avec les dimensions originales
        if (result.blocks) {
            result.blocks = enrichBlocksWithOriginalDimensions(result.blocks, stockData);
        }
        
        const endTime = performance.now();
        const optimizationTime = (endTime - startTime) / 1000;
        
        lastOptimizationResult = result;
        displayResults(result);
        
        // Sauvegarder silencieusement (sans notification intrusive)
        const projectId = simpleTracker.saveOptimization(
            wallConfig,
            result,
            stockData,
            optimizationTime
        );
        
        // Notification discr√®te et courte
        if (projectId) {
            showQuietNotification('üíæ Donn√©es sauvegard√©es');
        }
        
        // Debug: afficher les informations des blocs
        console.log('üîç Blocs apr√®s optimisation:', result.blocks?.map(b => ({
            ref: b.ref,
            cuts: b.cuts,
            originalLength: b.originalLength,
            originalWidth: b.originalWidth,
            usedWidth: b.width,
            usedHeight: b.height
        })));
        
    } catch (error) {
        showStatus('danger', '‚ùå Erreur lors de l\'optimisation: ' + error.message);
    } finally {
        optimizationInProgress = false;
        progressContainer.style.display = 'none';
    }
}

// ========================================
// NOTIFICATION DISCR√àTE
// ========================================

function showQuietNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed; bottom: 20px; right: 20px; 
        background: #27ae60; color: white; 
        padding: 8px 12px; border-radius: 4px; 
        font-size: 12px; z-index: 9999;
        opacity: 0; transition: opacity 0.3s ease;
        pointer-events: none;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Animation d'apparition
    setTimeout(() => notification.style.opacity = '1', 100);
    
    // Disparition apr√®s 2 secondes
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
            }
        }, 300);
    }, 2000);
}

// ========================================
// AFFICHAGE DES STATISTIQUES SIMPLE
// ========================================

function showSimpleStats() {
    const stats = simpleTracker.getStats();
    const suggestions = simpleTracker.getSuggestions();
    
    if (stats.error) {
        alert('üìä Aucune donn√©e collect√©e pour le moment.\nR√©alisez quelques optimisations pour voir vos statistiques !');
        return;
    }
    
    let message = 'üìä VOS STATISTIQUES\n\n';
    message += `Projets r√©alis√©s: ${stats.totalProjects}\n`;
    message += `Couverture moyenne: ${stats.avgCoverage.toFixed(1)}%\n`;
    message += `Efficacit√© moyenne: ${stats.avgEfficiency.toFixed(1)}%\n`;
    message += `D√©coupes moyennes: ${stats.avgCuts.toFixed(1)}\n`;
    message += `Violations moyennes: ${stats.avgViolations.toFixed(1)}\n`;
    message += `Temps moyen: ${stats.avgTime.toFixed(1)}s\n\n`;
    
    if (stats.topFamilies.length > 0) {
        message += 'üèÜ FAMILLES LES PLUS UTILIS√âES:\n';
        stats.topFamilies.forEach((family, index) => {
            message += `${index + 1}. ${family.family}: ${family.count} fois\n`;
        });
        message += '\n';
    }
    
    message += 'üí° SUGGESTIONS:\n';
    suggestions.forEach(suggestion => {
        message += `‚Ä¢ ${suggestion}\n`;
    });
    
    alert(message);
}

// ========================================
// EXPORT SIMPLE
// ========================================

function exportSimpleData() {
    const success = simpleTracker.exportData();
    if (success) {
        alert('‚úÖ Donn√©es export√©es avec succ√®s !');
    } else {
        alert('‚ùå Erreur lors de l\'export');
    }
}

// ========================================
// AJOUT DES BOUTONS SIMPLES
// ========================================

function addSimpleButtons() {
    const section = document.querySelector('.section:nth-child(2)');
    if (!section) return;
    
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        margin-top: 15px; 
        padding-top: 15px; 
        border-top: 1px solid #ddd;
    `;
    
    buttonContainer.innerHTML = `
        <div style="margin-bottom: 10px;">
            <h4 style="color: #2c3e50; margin-bottom: 8px; font-size: 14px;">üìä Donn√©es d'Optimisation</h4>
        </div>
        <div class="btn-grid">
            <button class="btn btn-secondary" onclick="showSimpleStats()">
                üìà Mes Statistiques
            </button>
            <button class="btn btn-warning" onclick="exportSimpleData()">
                üì• Exporter Donn√©es
            </button>
        </div>
    `;
    
    section.appendChild(buttonContainer);
}

// ========================================
// INITIALISATION SIMPLE
// ========================================

function initializeSimpleInterface() {
    // Initialisation de base
    updateStockDisplay();
    
    // Ajouter les boutons
    addSimpleButtons();
    
    // Validation des entr√©es (sans raccourcis clavier)
    const numberInputs = ['targetLength', 'targetWidth', 'targetThickness', 'numRows', 'jointOffset'];
    numberInputs.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener('blur', function() {
                const min = parseFloat(this.min) || 0;
                const max = parseFloat(this.max) || Infinity;
                let value = parseFloat(this.value) || min;
                
                if (value < min) value = min;
                if (value > max) value = max;
                
                this.value = value;
                updateStockDisplay();
            });
        }
    });

    console.log('‚úÖ Interface simple avec collecte de donn√©es pr√™te');
}


// Remplacer votre fonction optimizeWall par la version simple
window.optimizeWall = optimizeWallSimple;

// Initialiser au chargement
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(initializeSimpleInterface, 500);
});

console.log('‚úÖ Syst√®me de collecte simplifi√© charg√©');
</script>
<script>
    // ========================================
// D√âTAIL DES D√âCOUPES - CODE √Ä AJOUTER
// ========================================

// 1. FONCTION POUR CALCULER LES D√âTAILS DE D√âCOUPES
function calculateCuttingDetails(blocks) {
    const cuttingDetails = {
        totalBlocks: blocks.length,
        blocksWithCuts: 0,
        blocksWithoutCuts: 0,
        cutsByType: {
            lengthOnly: 0,
            widthOnly: 0,
            both: 0,
            none: 0
        },
        detailedCuts: [],
        totalWastePieces: 0,
        wasteByFamily: {}
    };

    blocks.forEach(block => {
        // Trouver le casier original dans le stock
        const originalStock = stockData.find(stock => stock.ref === block.ref);
        
        if (!originalStock) {
            console.warn(`Casier original ${block.ref} non trouv√© dans le stock`);
            return;
        }

        // Dimensions originales
        const originalLength = originalStock.length;
        const originalWidth = originalStock.width;
        const originalThickness = originalStock.thickness;

        // Dimensions utilis√©es dans le mur
        const usedLength = block.width;  // Dans votre code, block.width est la longueur utilis√©e
        const usedWidth = block.height;  // block.height est la largeur utilis√©e
        const usedThickness = originalThickness; // L'√©paisseur reste la m√™me

        // Calculer les d√©coupes n√©cessaires
        const needsCutLength = originalLength > usedLength;
        const needsCutWidth = originalWidth > usedWidth;
        const hasAnyCuts = needsCutLength || needsCutWidth;

        // Calculer les dimensions des chutes
        const wasteLength = needsCutLength ? originalLength - usedLength : 0;
        const wasteWidth = needsCutWidth ? originalWidth - usedWidth : 0;

        if (hasAnyCuts) {
            cuttingDetails.blocksWithCuts++;
            
            // Classifier le type de d√©coupe
            if (needsCutLength && needsCutWidth) {
                cuttingDetails.cutsByType.both++;
            } else if (needsCutLength) {
                cuttingDetails.cutsByType.lengthOnly++;
            } else if (needsCutWidth) {
                cuttingDetails.cutsByType.widthOnly++;
            }

            // Calculer les chutes d√©taill√©es
            const wasteDetails = [];

            if (needsCutLength && wasteLength > 5) { // Ignorer les tr√®s petites chutes
                wasteDetails.push({
                    type: 'Chute longueur',
                    dimensions: `${wasteLength} √ó ${originalWidth} √ó ${originalThickness}`,
                    volume: wasteLength * originalWidth * originalThickness
                });
            }

            if (needsCutWidth && wasteWidth > 5) { // Ignorer les tr√®s petites chutes
                wasteDetails.push({
                    type: 'Chute largeur',
                    dimensions: `${usedLength} √ó ${wasteWidth} √ó ${originalThickness}`,
                    volume: usedLength * wasteWidth * originalThickness
                });
            }

            // Chute d'angle si d√©coupe sur les deux dimensions
            if (needsCutLength && needsCutWidth && wasteLength > 5 && wasteWidth > 5) {
                wasteDetails.push({
                    type: 'Chute angle',
                    dimensions: `${wasteLength} √ó ${wasteWidth} √ó ${originalThickness}`,
                    volume: wasteLength * wasteWidth * originalThickness
                });
            }

            // Calculer le volume total de chutes
            const totalWasteVolume = wasteDetails.reduce((sum, waste) => sum + waste.volume, 0);
            
            // D√©tail de la d√©coupe
            const cutDetail = {
                ref: block.ref,
                family: block.family || 'N/A',
                quality: block.quality || 'N/A',
                // Dimensions originales
                originalDimensions: `${originalLength} √ó ${originalWidth} √ó ${originalThickness}`,
                originalLength: originalLength,
                originalWidth: originalWidth,
                originalThickness: originalThickness,
                // Dimensions utilis√©es
                usedDimensions: `${usedLength} √ó ${usedWidth} √ó ${usedThickness}`,
                usedLength: usedLength,
                usedWidth: usedWidth,
                usedThickness: usedThickness,
                // Informations sur les d√©coupes
                cutType: needsCutLength && needsCutWidth ? 'Longueur + Largeur' : 
                         needsCutLength ? 'Longueur seulement' : 'Largeur seulement',
                needsCutLength: needsCutLength,
                needsCutWidth: needsCutWidth,
                // Dimensions des chutes
                wasteLength: wasteLength,
                wasteWidth: wasteWidth,
                wasteDetails: wasteDetails,
                wasteVolume: totalWasteVolume,
                // Autres informations
                row: block.row,
                position: `(${block.x}, ${block.y})`,
                cuts: block.cuts || 0,
                violatesJoints: block.violatesJoints || false,
                efficiency: ((usedLength * usedWidth * usedThickness) / (originalLength * originalWidth * originalThickness)) * 100
            };
            
            cuttingDetails.detailedCuts.push(cutDetail);
            
            // Calculer les chutes par famille
            const family = block.family || 'N/A';
            if (!cuttingDetails.wasteByFamily[family]) {
                cuttingDetails.wasteByFamily[family] = {
                    totalWaste: 0,
                    blocksCount: 0
                };
            }
            cuttingDetails.wasteByFamily[family].totalWaste += totalWasteVolume;
            cuttingDetails.wasteByFamily[family].blocksCount++;
            
        } else {
            cuttingDetails.blocksWithoutCuts++;
            cuttingDetails.cutsByType.none++;
        }
    });

    cuttingDetails.totalWastePieces = cuttingDetails.blocksWithCuts;

    return cuttingDetails;
}
// 2. FONCTION POUR AFFICHER LES D√âTAILS DE D√âCOUPES
function showCuttingDetails() {
    if (!lastOptimizationResult || !lastOptimizationResult.blocks) {
        alert('Aucune optimisation disponible. Lancez d\'abord une optimisation.');
        return;
    }

    const details = calculateCuttingDetails(lastOptimizationResult.blocks);
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.5); display: flex; align-items: center; 
        justify-content: center; z-index: 10000;
    `;
    
    // Construire le tableau des d√©coupes AM√âLIOR√â
    let cutsTableHtml = '';
    if (details.detailedCuts.length > 0) {
        cutsTableHtml = `
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; margin-top: 10px;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
                    <thead style="background: #34495e; color: white; position: sticky; top: 0;">
                        <tr>
                            <th style="padding: 8px; text-align: left; min-width: 80px;">Casier</th>
                            <th style="padding: 8px; text-align: left; min-width: 80px;">Famille</th>
                            <th style="padding: 8px; text-align: left; min-width: 120px;">Dim. Originales</th>
                            <th style="padding: 8px; text-align: left; min-width: 120px;">Dim. Utilis√©es</th>
                            <th style="padding: 8px; text-align: left; min-width: 100px;">Type D√©coupe</th>
                            <th style="padding: 8px; text-align: left; min-width: 150px;">Chutes G√©n√©r√©es</th>
                            <th style="padding: 8px; text-align: center; min-width: 60px;">Rang√©e</th>
                            <th style="padding: 8px; text-align: center; min-width: 80px;">Efficacit√©</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${details.detailedCuts.map(cut => {
                            // Construire le d√©tail des chutes
                            let wastesText = '';
                            if (cut.wasteDetails.length > 0) {
                                wastesText = cut.wasteDetails.map(waste => 
                                    `<div style="margin-bottom: 2px;"><strong>${waste.type}:</strong> ${waste.dimensions}</div>`
                                ).join('');
                            } else {
                                wastesText = '<div style="color: #27ae60;">Aucune chute</div>';
                            }

                            const efficiencyColor = cut.efficiency >= 80 ? '#27ae60' : 
                                                   cut.efficiency >= 60 ? '#f39c12' : '#e74c3c';

                            return `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 8px; font-weight: 600; color: #2980b9;">${cut.ref}</td>
                                    <td style="padding: 8px; font-size: 0.75rem; color: #666;">${cut.family}</td>
                                    <td style="padding: 8px; font-family: monospace;">
                                        <div><strong>L:</strong> ${cut.originalLength}mm</div>
                                        <div><strong>l:</strong> ${cut.originalWidth}mm</div>
                                        <div><strong>√â:</strong> ${cut.originalThickness}mm</div>
                                    </td>
                                    <td style="padding: 8px; font-family: monospace; color: #27ae60;">
                                        <div><strong>L:</strong> ${cut.usedLength}mm</div>
                                        <div><strong>l:</strong> ${cut.usedWidth}mm</div>
                                        <div><strong>√â:</strong> ${cut.usedThickness}mm</div>
                                    </td>
                                    <td style="padding: 8px; color: ${cut.cutType.includes('+') ? '#e74c3c' : '#f39c12'};">
                                        <div style="font-weight: 600;">${cut.cutType}</div>
                                        ${cut.needsCutLength ? `<div style="font-size: 0.7rem;">‚úÇÔ∏è L: -${cut.wasteLength}mm</div>` : ''}
                                        ${cut.needsCutWidth ? `<div style="font-size: 0.7rem;">‚úÇÔ∏è l: -${cut.wasteWidth}mm</div>` : ''}
                                    </td>
                                    <td style="padding: 8px; font-size: 0.75rem;">
                                        ${wastesText}
                                        ${cut.wasteVolume > 0 ? `<div style="margin-top: 4px; color: #e74c3c; font-weight: 600;">Total: ${Math.round(cut.wasteVolume).toLocaleString()} mm¬≥</div>` : ''}
                                    </td>
                                    <td style="padding: 8px; text-align: center; font-weight: 600;">${cut.row}</td>
                                    <td style="padding: 8px; text-align: center; color: ${efficiencyColor}; font-weight: 600;">${cut.efficiency.toFixed(1)}%</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
        `;
    } else {
        cutsTableHtml = `
            <div style="text-align: center; padding: 20px; background: #d4edda; border-radius: 6px; color: #155724; margin-top: 10px;">
                üéâ <strong>Aucune d√©coupe n√©cessaire !</strong><br>
                Tous les blocs sont utilis√©s dans leurs dimensions originales.
            </div>
        `;
    }

    // Construire les statistiques des chutes par famille (inchang√©)
    const wasteByFamilyHtml = Object.keys(details.wasteByFamily).length > 0 ? `
        <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-top: 15px;">
            <h4 style="color: #856404; margin-bottom: 10px;">üìä Chutes par Famille</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                ${Object.entries(details.wasteByFamily).map(([family, data]) => `
                    <div style="padding: 8px; background: white; border-radius: 4px; border-left: 3px solid #f39c12;">
                        <strong>${family}</strong><br>
                        <small>${data.blocksCount} blocs ‚Ä¢ ${Math.round(data.totalWaste).toLocaleString()} mm¬≥</small>
                    </div>
                `).join('')}
            </div>
        </div>
    ` : '';

    modal.innerHTML = `
        <div style="background: white; padding: 25px; border-radius: 10px; max-width: 1200px; width: 95%; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin-bottom: 20px; color: #2c3e50; display: flex; align-items: center; gap: 10px;">
                ‚úÇÔ∏è D√©tail des D√©coupes
            </h3>
            
            <!-- R√©sum√© des d√©coupes (inchang√©) -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #2980b9;">${details.totalBlocks}</div>
                    <div style="font-size: 0.9rem; color: #666;">Blocs total</div>
                </div>
                <div style="background: #ffe6e6; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #e74c3c;">${details.blocksWithCuts}</div>
                    <div style="font-size: 0.9rem; color: #666;">Blocs d√©coup√©s</div>
                </div>
                <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #27ae60;">${details.blocksWithoutCuts}</div>
                    <div style="font-size: 0.9rem; color: #666;">Blocs entiers</div>
                </div>
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #f39c12;">${details.totalWastePieces}</div>
                    <div style="font-size: 0.9rem; color: #666;">Chutes cr√©√©es</div>
                </div>
            </div>

            <!-- Types de d√©coupes (inchang√©) -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <h4 style="color: #2c3e50; margin-bottom: 10px;">üìã Types de D√©coupes</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 0.9rem;">
                    <div>‚úÇÔ∏è Longueur seule: <strong>${details.cutsByType.lengthOnly}</strong></div>
                    <div>‚úÇÔ∏è Largeur seule: <strong>${details.cutsByType.widthOnly}</strong></div>
                    <div>‚úÇÔ∏è Les deux: <strong>${details.cutsByType.both}</strong></div>
                    <div>‚úÖ Aucune: <strong>${details.cutsByType.none}</strong></div>
                </div>
            </div>

            <!-- Tableau d√©taill√© AM√âLIOR√â -->
            <div>
                <h4 style="color: #2c3e50; margin-bottom: 10px;">üîç D√©tail des D√©coupes par Bloc</h4>
                <div style="background: #e8f4fd; padding: 10px; border-radius: 6px; margin-bottom: 10px; font-size: 0.85rem;">
                    <strong>üí° L√©gende:</strong> 
                    Dim. Originales = taille du casier en stock ‚Ä¢ 
                    Dim. Utilis√©es = taille dans le mur ‚Ä¢ 
                    Chutes = morceaux restants apr√®s d√©coupe
                </div>
                ${cutsTableHtml}
            </div>

            ${wasteByFamilyHtml}

            <!-- Boutons (inchang√©s) -->
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="exportCuttingDetailsToCSV()" style="margin-right: 10px; padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üì• Exporter D√©coupes CSV
                </button>
                <button onclick="closeCuttingDetails()" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Fermer
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Fonctions des boutons (inchang√©es)
    window.closeCuttingDetails = function() {
        document.body.removeChild(modal);
    };
    
    window.exportCuttingDetailsToCSV = function() {
        exportDetailedCuttingDetailsToCSV(details);
    };
}

// 3. FONCTION POUR EXPORTER LES D√âCOUPES EN CSV
function exportDetailedCuttingDetailsToCSV(details) {
    if (details.detailedCuts.length === 0) {
        alert('Aucune d√©coupe √† exporter !');
        return;
    }

    // Pr√©parer les donn√©es CSV avec plus de d√©tails
    const csvData = details.detailedCuts.map(cut => ({
        'Casier': cut.ref,
        'Famille': cut.family,
        'Qualit√©': cut.quality,
        'Rang√©e': cut.row,
        'Position': cut.position,
        
        // Dimensions originales
        'Original_L_mm': cut.originalLength,
        'Original_l_mm': cut.originalWidth,
        'Original_√â_mm': cut.originalThickness,
        'Volume_Original_mm3': cut.originalLength * cut.originalWidth * cut.originalThickness,
        
        // Dimensions utilis√©es
        'Utilis√©_L_mm': cut.usedLength,
        'Utilis√©_l_mm': cut.usedWidth,
        'Utilis√©_√â_mm': cut.usedThickness,
        'Volume_Utilis√©_mm3': cut.usedLength * cut.usedWidth * cut.usedThickness,
        
        // D√©coupes
        'Type_D√©coupe': cut.cutType,
        'D√©coupe_Longueur': cut.needsCutLength ? 'Oui' : 'Non',
        'D√©coupe_Largeur': cut.needsCutWidth ? 'Oui' : 'Non',
        'Chute_L_mm': cut.wasteLength,
        'Chute_l_mm': cut.wasteWidth,
        
        // Chutes d√©taill√©es
        'Chutes_D√©tail': cut.wasteDetails.map(w => `${w.type}: ${w.dimensions}`).join(' | '),
        'Volume_Chutes_mm3': Math.round(cut.wasteVolume),
        'Efficacit√©_%': cut.efficiency.toFixed(1),
        
        // Autres
        'Violations_Jointures': cut.violatesJoints ? 'Oui' : 'Non'
    }));

    // Convertir en CSV
    const headers = Object.keys(csvData[0]);
    const csvRows = [headers.join(',')];
    
    csvData.forEach(row => {
        const values = headers.map(header => {
            const value = row[header];
            return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
        });
        csvRows.push(values.join(','));
    });

    const csv = csvRows.join('\n');

    // T√©l√©charger le fichier
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `detailDecoupesAmeliore_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    alert('‚úÖ D√©tail am√©lior√© des d√©coupes export√© en CSV !');
}

console.log('‚úÖ Tableau des d√©coupes am√©lior√© avec d√©tails complets');


</script>
</body>
</html>